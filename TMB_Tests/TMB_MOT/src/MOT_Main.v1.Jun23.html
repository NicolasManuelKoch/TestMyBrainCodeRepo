<!DOCTYPE html>

<html lang="en">

<head>

<!-- Metadata ************************************************************** -->

    <meta charset="UTF-8">
    <meta name="description" content="TMB Multiple Object Tracking">
    <meta name="copyright" content="2023 The Many Brains Project, Inc. and McLean Hospital LGPLv3">
    <meta name="author" content="Paolo Martini, Roger Strong">
    <meta name="keywords" content="cognitive test, brain test">

    <!-- Configs for mobiles -->

    <!-- Set the viewport. -->
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=contain">

    <!-- Allow web app to be run in full-screen mode. -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Make the app title different than the page title. -->
    <meta name="apple-mobile-web-app-title" content="MOT test">

    <!-- Set the theme color -->
    <meta name="theme-color" content="white">

<!-- End of metadata ******************************************************* -->

<!-- Links to Icons. ********************************************************-->

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" href="/favicon.ico">

<!-- end of icons ********************************************************** -->

<!-- Â© 2023 The Many Brains Project, Inc. and McLean Hospital.

     This code is made available under a GNU Lesser General Public License 3.0
     (LGPLv3).
     https://www.gnu.org/licenses/lgpl-3.0.html.

     For Usage, enter:

       MOT.html?help

     For reference see:


-->

<!-- Title ***************************************************************** -->

    <title>TMB Multiple Object Tracking</title>

<!-- End of Title ********************************************************** -->

<!-- css Style declarations and stylesheets ******************************** -->

    <style>

        *
        {
            border-radius: 0;
            box-sizing: border-box;
        }

        *::after, *::before
        {
            box-sizing: border-box;
        }
        
        html
		{
			width: 100vw;
			height: 100vh;
		}

        body
        {
            width: 100vw;
            height: 100vh;
            margin: auto;
            background: #ffffff;
            color: #000000;
            font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
            font-size: 13pt;
            text-align: center;
        }

        .stim
        {
            width: 500px;
            height: 500px;
            background-color: white;
            position:absolute;
            left:50%;
            top:50%;
            margin-top: -270px;
            margin-left: -250px;
            display: none;
        }

        #feedback
        {
            width: 500px;
            height: 40px;
            background-color: white;
            position:absolute;
            left:50%;
            top:50%;
            margin-top: 230px;
            margin-left: -250px;
            font-size: 25pt;
            display: none;
        }

        #textLeft
        {
            float: left;
            width: 30%;
            text-align: left;
        }

        #textMiddle
        {
            width: 60%;
            text-align: center;
            color: blue;
        }

        #textRight
        {
            float: right;
            width: 30%;
            text-align: right;
        }

        .button
        {
            font-size: 1.2em;
            line-height: 1.5em;
            border: 2px solid #f1c40f;
            border-radius: 1em;
            text-align: center;
            background: transparent;
            color: #000000;
            box-shadow: 0 5px 15px 5px grey
        }

        .button:active
        {
            box-shadow: 0 5px 15px 1px lightgrey
        }

        .button:focus
        {
            outline: none
        }

        select
        {
            font-size: 20pt;
        }

    </style>

<!-- end of css Style declarations ***************************************** -->

<!-- required js libraries ************************************************* -->

    <script type="text/javascript" src="snap.0.5.1.min.js"></script>
    <script type="text/javascript" src="TestMyBrain.12.18.min.js"></script>
    <script type="text/javascript" src="TestHelper.v1.May23.js"></script>

<!-- end of required js libraries ****************************************** -->

<!-- js script ************************************************************* -->

    <script type="text/javascript">

        var circle = [];            // Array of SVG circles objects
        var happy =[];              // array of happy targets
        var sad = [];               // array of sad targets
        var mycircle = {x:[],       // circle x
                        y:[],       // circle y
                        d:[],       // circle motion direction in deg
                        r:15,       // circle radius
                        z:4,        // circle repulsion radius
                        noise: 15,  // motion direction noise in deg
                        speed: 2};  // circle speed in pixels/frame
        var numCircles = 10;        // total # of circles
        var numTargets;             // # of targets to track
        var targets = [];           // array indicating whether targets are clicked
        var animationFrames;		// how many frames should be used when interpolating trajectories
        var frameCount = 0;			// used for counting frames each trial
        var clicks = 0;             // # of clicks
        var targetClicks = 0;       // # of clicked targets
        var duration = 5000;        // desired duration of trial in ms
        var trueDuration;           // measured duration of trial in ms
        var frametime = 0;          // measured display frame duration in ms
        var paper;                  // stimulus graphics page
        var paperSize = 500;        // size of stimulus graphics page
        var timeoutRef;             // reference to the click timeout trap
        var clickTimeout = 15000;   // timeout for clicking on targets
        var frameSequence = [];     // object containing the sequence of frames and their properties
        var frame;                  // single frame object
        var timestamp;              // used for timing
        var rt;                     // reaction time
        var practiceErr = 0;        // practice errors counter
        var trialCount = 0;         // trial counter
        var results = [];           // to store trials details and responses
        var outcomes = {};          // object containing outcome variables
        var score = 0;              // cumulative correct hits
        var total = 0;              // max possible score
        var dots = 10;              // URL parameter: if we want # of dots
        var seed = 1;               // URL parameter: random number generator seed
        var debug;                  // URL parameter: output to console
        var demo = false;           // URL parameter: run in demo mode
        var showresults;            // URL parameter: if they want to show results in a popup window
        var autosave;               // URL parameter: if they want to save data in a file automatically
        var filename;               // URL parameter: filename for data
        var usage = "";             // URL parameter: show usage
        var noPractice;				// URL parameter: whether the participant can skip the practice trials		
        var ema;					// URL parameter: whether to use the EMA version of the test
        var practiceChoice = null;	// whether the participant chose to complete optional practice trials
		
		// message when practice trials are skipped
		function beginNoPractice()
        {
            showAlert("<label for='practice'>" +
                      "You are about to take:<br>" +
                      "TMB Multiple Object Tracking.<br><br>" +
                      "If you have taken this test before,<br>" +
                      "please choose whether to:</label><br><br>" +
                      "<select id='practice' name='practice' size=2 autocomplete='off'>" +
                      "<option value='skip'>Skip the practice trials</option>" +
                      "<option value='noSkip' selected>Re-take the practice trials</option>" +
                      "</select><br><br>",
                      "Click here to continue",
                      function ()
                      {
                          practiceChoice = document.getElementById('practice').value;
                          setFrameSequence();
                      },
                      '20pt');
        }
		
        // measure frametime in ms
        function getFrameTime(frames,callBack)
        {
            var t = [], frameTime;

            function arrMedian(arr)
            {
                if (!arr.length) return null;

                var ar = arr.slice();
                var mid = Math.floor(ar.length / 2);

                ar.sort(function (a,b){return a - b});

                if ((ar.length % 2) === 1)
                    return ar[mid];
                else
                    return (ar[mid - 1] + ar[mid]) / 2;
            }

            function getRate(tStamp)
            {
                t.push(tStamp);
                frames--;

                if(frames) requestAnimationFrame(getRate);
                else
                {
                    t = t.slice(2).map(function(n,i){return n - t[i+1]});
                    frameTime = arrMedian(t);
                    if(typeof callBack === "function") callBack(frameTime);
                    else console.log('frameTime = '+frameTime+'ms',
                                     'frameRate = '+1000/frameTime+'Hz',
                                     t);
                }
            }

            if(!frames) frames = 12;
            else frames += 2;
            requestAnimationFrame(getRate);
        }

        // interpolate an array
        // see http://hevi.info/do-it-yourself/interpolating-and-array-to-fit-another-size/
        function interpolateArray(data, fitCount)
        {
            var linearInterpolate = function (before, after, atPoint)
            {
                return before + (after - before) * atPoint;
            };

            var newData = [];
            var springFactor = (data.length - 1) / (fitCount - 1);
            newData[0] = data[0];

            for ( var i = 1; i < fitCount - 1; i++)
            {
                var tmp = i * springFactor;
                var before = (Math.floor(tmp)).toFixed();
                var after = (Math.ceil(tmp)).toFixed();
                var atPoint = tmp - before;
                newData[i] = linearInterpolate(data[before], data[after], atPoint);
            }
            newData[fitCount - 1] = data[data.length - 1];

            return newData;
        }

        // pre-compute circle trajectories
        function computeTrajectories()
        {
            // - add noise to the velocity vector
            // - bounce circles off elastic boundaries
            // - avoid collisions b/w circles
            // all computations are done outside the DOM

            var oldX, oldY;
            var newX, newY, newD;
            var velocityX, velocityY;
            var tooClose = true;
            var timeout = 0, sign = 1;
            var noise = Snap.rad(mycircle.noise);
            var repulsion = mycircle.z * mycircle.r;
            var i, f, distance;

            // from the desired duration, compute the needed motion frames,
            // assuming an exact 60 Hz framerate
            var motionFrames = Math.floor(duration/1000*60);

            for(f = 0; f < motionFrames; f++)
            {
                for(i = 0; i < numCircles; i++)
                {
                    // save the current dot's coordinates
                    oldX = mycircle.x[i][f];
                    oldY = mycircle.y[i][f];

                    // update direction vector with noise
                    newD = mycircle.d[i][f] + Math.random() * 2.0 * noise - noise;

                    // compute x and y shift
                    velocityX = Math.cos(newD) * mycircle.speed;
                    velocityY = Math.sin(newD) * mycircle.speed;

                    // compute new x and y coordinates
                    newX = oldX + velocityX;
                    newY = oldY + velocityY;

                    // compute a random sign
                    sign = randSign();

                    // avoid collisions
                    for(var j = 0; j < numCircles; j++)
                    {
                        // skip self
                        if(j === i) continue;

                        // we look ahead one step:
                        // if the next move collides, the direction is updated
                        // until there's no collision or timeout
                        tooClose = true;
                        timeout = 0;
                        while(tooClose && timeout < 100)
                        {
                            timeout++;

                            if (j > i) distance = euclidDistance(newX,newY,
                                                                 mycircle.x[j][f],
                                                                 mycircle.y[j][f]);
                            else distance = euclidDistance(newX,newY,
                                                           mycircle.x[j][f+1],
                                                           mycircle.y[j][f+1]);

                            if(distance <= repulsion)
                            {
                                // update vector direction
                                newD += sign * 0.05 * Math.PI;
                                // recompute  x shift and x coordinate
                                velocityX = Math.cos(newD) * mycircle.speed;
                                newX = oldX + velocityX;
                                // recompute  y shift and y coordinate
                                velocityY = Math.sin(newD) * mycircle.speed;
                                newY = oldY + velocityY;
                            }
                            else tooClose=false;
                        }
                    }

                    // enforce elastic boundaries
                    if(newX >= paperSize - mycircle.r || newX <= mycircle.r)
                    {
                        // bounce off left or right boundaries
                        velocityX *= -1; //invert x component of velocity vector
                        newX = oldX + velocityX; // recompute new x coordinate
                    }
                    if(newY >= paperSize - mycircle.r || newY <= mycircle.r)
                    {
                        // bounce off top or bottom boundaries
                        velocityY *= -1; //invert y component of velocity vector
                        newY = oldY + velocityY; // recompute new y coordinate
                    }

                    // assign new coordinates to each circle
                    mycircle.x[i][f+1] = newX;
                    mycircle.y[i][f+1] = newY;

                    // compute final vector direction
                    // use atan2 (not atan)!
                    mycircle.d[i][f+1] = Math.atan2(velocityY,velocityX);
                }
            }

            // adjust trajectories based upon device refresh rate
            // (i.e. down or up sample)
            animationFrames = Math.floor(duration / frametime) + 1;
            for (i = 0; i < numCircles; i++)
            {
                mycircle.x[i] = interpolateArray(mycircle.x[i], animationFrames);
                mycircle.y[i] = interpolateArray(mycircle.y[i], animationFrames);
            }
        }

        // initialize the dots
        function setup()
        {
            var tooClose;

            // initialize start positions and motion directions randomly
            for(var i = 0; i < numCircles; i++)
            {
                // mycircle.x[circleNum][frameNum]
                mycircle.x[i] = [];
                mycircle.y[i] = [];
                mycircle.d[i] = [];

                mycircle.x[i][0] = Math.random() * (paperSize - 2.0 * mycircle.r) +
                                   mycircle.r;
                mycircle.y[i][0] = Math.random() * (paperSize - 2.0 * mycircle.r) +
                                   mycircle.r;
                mycircle.d[i][0] = Math.random() * 2 * Math.PI;
            }

            // enforce proximity limits
            for(i = 1; i < numCircles; i++)
            {
                // this loop repositions each circle until it's outside
                // the repulsion area of all other circles
                tooClose = true;
                while(tooClose)
                {
                    mycircle.x[i][0] = Math.random() * (paperSize - 2.0 * mycircle.r) +
                                       mycircle.r;
                    mycircle.y[i][0] = Math.random() * (paperSize - 2.0 * mycircle.r) +
                                       mycircle.r;

                    // repulsion distance defaults to 5 times the circle's radius
                    tooClose = false;
                    for (var j = 0; j < i; j++)
                    {
                        if(euclidDistance(mycircle.x[i][0],mycircle.y[i][0],
                                          mycircle.x[j][0],mycircle.y[j][0]) < 5 * mycircle.r)
                        {
                            tooClose = true;
                            break;
                        }
                    }
                }
            }

            // when done, update the circles on the DOM
            for(i = 0; i < numCircles; i++)
            {
                circle[i] = paper.circle(mycircle.x[i][0], // cx
                                         mycircle.y[i][0], // cy
                                         mycircle.r);   // r
                circle[i].attr({fill: "black"});        // colour
                circle[i].data("index", i);             // index tag
            }

            // draw a box for the circles
            paper.rect(0,0,paperSize,paperSize).attr({"stroke": "black",
                                                      "stroke-width": "2px",
                                                      "fill": "none"});

            // create numtargets happy green dots and hide them
            for(i = 0; i < numTargets; i++)
            {
                happy[i] = paper.image("happy-green-border.jpg",
                                       0, 0, 2 * mycircle.r, 2 * mycircle.r);
                happy[i].node.style.display = "none";
            }
            // create numcircles sad red dots and hide them
            for(i = 0; i < numCircles; i++)
            {
                sad[i] = paper.image("sad-red-border.jpg",
                                     0,0,2*mycircle.r,2*mycircle.r);
                sad[i].node.style.display = "none";
            }

            // pre-compute the dot trajectories
            computeTrajectories();
        }

        // update the position of the circles for the next frame
        function moveCircles()
        {
        	frameCount++;
        	for(var i = 0; i < numCircles; i++)
			{
                // now we update the DOM elements
                circle[i].node.setAttribute ("cx", mycircle.x[i][frameCount]);
                circle[i].node.setAttribute ("cy", mycircle.y[i][frameCount]);
            }
        }

        function ShowTargets()
        {
            // move the happy green smileys to the coordinates
            // of the targets, make them visible and hide the dots
            for(var i = 0; i < numTargets; i++)
            {
                happy[i].attr({"x": circle[i].attr("cx")-mycircle.r,
                               "y": circle[i].attr("cy")-mycircle.r});
                happy[i].node.style.display = "block";
                circle[i].node.style.display = "none";
            }
        }

        function HideTargets()
        {
            // make the dots visible and hide the smileys
            for(var i = 0; i < numTargets; i++)
            {
                happy[i].node.style.display = "none";
                circle[i].node.style.display = "block";
            }
        }

        var clickHandler = function (e)
        {
            // this handler listens for clicks on the targets
            // reveals correct and incorrect clicks
            // stops listening after numTargets clicks
            // gives feedback and paces the trial presentation

            var i;

            // retrieve the identity of this dot
            var index = this.data("index");

            // increment the clicks counter
            clicks++;

            // mark correct as green
            if(index < numTargets)
            {
                happy[index].attr({"x": circle[index].attr("cx")-mycircle.r,
                                   "y": circle[index].attr("cy")-mycircle.r});
                happy[index].node.style.display = "block";
                circle[index].node.style.display = "none";
                //circle[index].attr({fill: "chartreuse"});

                // check they are not clicking on an already clicked target
                if(targets[index] === 0)
                {
                    targets[index] = 1;
                    targetClicks++;

                    if (frame.type === "test")
                    {
                        // update the score
                        score++;
                        getID("textRight").innerHTML = "Score "+score;
                    }
                }
            }
            // mark wrong as red
            else
            {
                sad[index].attr({"x": circle[index].attr("cx")-mycircle.r,
                                 "y": circle[index].attr("cy")-mycircle.r});
                sad[index].node.style.display = "block";
                circle[index].node.style.display = "none";
            }

            // check if we got enough clicks
            if(clicks === numTargets)
            {
                rt = timestamp;
                timestamp = now();
                rt = timestamp - rt;

                // clear the click timeout trap
                clearTimeout(timeoutRef);

                // disable the click handlers
                for(i = 0; i < numCircles; i++) circle[i].unclick();

                // push this trial in the results record
                results.push(
                {
                    type: frame.type, // one of practice or test
                    hits: targetClicks,
                    rt: rt.round(2),
                    numTargets: numTargets,
                    numdots: numCircles,
                    speed: mycircle.speed,
                    noise: mycircle.noise,
                    duration: trueDuration.round(2),
                    frametime: frametime.round(2), // duration of a frame in ms
                    state: e.type,
                    seed: frame.message
                });

                // if we are debugging, log the results
                if(debug === 'true') logResults(results,'inc');

                if(frame.type === "test")
                {
                    // update total
                    total += numTargets;

                    // start a new trial
                    setTimeout(function () {nextTrial();}, 1500);
                }
                else if(frame.type === "practice")
                {
                    var msg = "<br><br><br><br>You got " + targetClicks +
                              " of " + numTargets +
                              " dots correct.<br><br><br>";

                    // deal with practice errors
                    if(targetClicks < numTargets)
                    {
                        // we allow repeating practice trials 2 times
                        if(practiceErr < 2)
                        {
                            // rewind the trials chain by one
                            frameSequence.unshift(frame);

                            msg = "<br><br>Let's try again.<br><br>"+
                                  "When the movement stops,<br>"+
                                  "click the " + numTargets +
                                  " dots that flashed.<br><br><br>";

                            practiceErr++;
                        }
                    }
                    else practiceErr = 0;

                    // give feedback
                    setTimeout(function ()
                    {
                        showAlert(msg,
                                  "Click here to continue",
                                  function ()
                                  {
                                      showFrame("null");
                                      nextTrial();
                                  },
                                  '20pt');
                    }, 500);
                }
            }
        };

        function showMovingDots()
        {
            var motionTimer = 0;

            // clear the canvas and feedback text
            if(paper) paper.clear();
            getID("textMiddle").innerHTML = "";

            // show the stimulus DIV and hide all others
            showFrame("canvasContainer","feedback");

            // set the random seed for each trial
            Math.seedrandom(frame.message);

            // initialize the dots
            setup();

            if(frame.type === "test")
            {
                // update and show the trial counter and score
                if(trialCount === 6 || demo === "true") trialCount = 0;
                trialCount++;
                getID("textLeft").innerHTML = trialCount + ' of 6';
                getID("textRight").innerHTML = 'Score ' + score;
            }

            // then set the motion scheduler
            function update()
            {
                // get a timestamp for the beginning of the motion
                if(!motionTimer) trueDuration = now();

                // increment the frame counter
                motionTimer++;

                // animate
                moveCircles();

                // exit the animation when we have reached the required duration
                if(motionTimer === animationFrames - 1)
                {
                    // compute real duration
                    trueDuration = now() - trueDuration;

                    // show the cursor again
                    showCursor("canvasContainer");

                    if (frame.type === "practice" ||
                        frame.type === "test")
                    {
                        // start recording clicks
                        for (var j = 0; j < numCircles; j++)
                            circle[j].click(clickHandler);

                        // set a timeout trap
                        timeoutRef = setTimeout(function ()
                        {
                            // remove the click handlers
                            for(var k = 0; k < numCircles; k++)
                                circle[k].unclick(clickHandler);

                            results.push(
                            {
                                type: frame.type, // practice or test
                                hits: 0, // number of correct target clicks
                                rt: 0, // rt for this trial
                                numTargets: numTargets, // # of target dots
                                numdots: numCircles, // # of total dots
                                speed: mycircle.speed, // dot speed pixels/frame
                                noise: mycircle.noise, // +-deg added randomly to direction
                                duration: trueDuration.round(2), // total ms of animation
                                frametime: frametime.round(2), // duration of a frame in ms
                                state: 'timeout', // click or timeout
                                seed: frame.message // random generator seed for this trial
                            });

                            // subtract any points they got before timing out
                            if (frame.type === "test")
							{
								score = score - targetClicks;
								getID("textRight").innerHTML = "Score "+score;
							}

                            // if we are debugging, log the results
                            if(debug === 'true') logResults(results,'inc');

                            if(frame.type === "test" && trialCount > 0)
                                trialCount--;
                            frameSequence.unshift(frame);

                            showAlert("You took too long to respond!<br><br>" +
                                      "Remember:<br>once the movement stops,<br>" +
                                      "click the dots that flashed.<br><br><br>",
                                      "Click here to retry",
                                      function ()
                                      {
                                          showFrame("null");
                                          nextTrial();
                                      },
                                      '20pt');

                        }, clickTimeout);

                        // initialize the clicks counter
                        clicks = 0;
                        targetClicks = 0;

                        // get a timestamp to calculate RT
                        timestamp = now();

                        if (frame.type === "practice")
                            getID("textMiddle").innerHTML = "Click the " +
                                                            numTargets +
                                                            " dots that flashed!";

                        else if (frame.type === "test")
                            getID("textMiddle").innerHTML = "Click " + numTargets +
                                                            " dots"
                    }
                    else setTimeout(function ()
                    {
                        nextTrial();
                    }, 1500);
                }
                else requestAnimationFrame(update);
            }

            chainTimeouts(
            function(){hideCursor("canvasContainer");},500,
            function(){requestAnimationFrame(ShowTargets);},100,
            function(){requestAnimationFrame(HideTargets);},100,
            function(){requestAnimationFrame(ShowTargets);},100,
            function(){requestAnimationFrame(HideTargets);},100,
            function(){requestAnimationFrame(ShowTargets);},100,
            function(){requestAnimationFrame(HideTargets);},100,
            function(){requestAnimationFrame(ShowTargets);},100,
            function(){requestAnimationFrame(HideTargets);},100,
            function(){requestAnimationFrame(ShowTargets);},100,
            function(){requestAnimationFrame(HideTargets);},1500,
            function ()
            {
                motionTimer = 0;

                requestAnimationFrame(update);
            });
        }

        function nextTrial()
        {
            // read the frame sequence one frame at a time
            frame = frameSequence.shift();
            if(frame)
            {
                // check if it's the startup frame
                if (frame.type === "begin")
                    showAlert(frame.message,
                              "Click here for instructions",
                              function ()
                              {
                                  nextTrial();
                              },
                              '20pt');
                // else if it's a message frame, show it
                else if (frame.type === "message")
                    showAlert(frame.message,
                              "Click here to continue",
                              function ()
                              {
                                  showFrame("null");
                                  nextTrial();
                              },
                              '20pt');
                // else show the animation
                else
                {
                    numCircles = frame.n_circles;
                    numTargets = frame.n_targets;
                    mycircle.speed = frame.speed;
                    duration = frame.duration;
                    frameCount = 0;

                    for(var i = 0; i < numTargets; i++) targets[i] = 0;

                    getFrameTime(10,function(interval)
                    {
                        frametime = interval;
                        showMovingDots();
                    });

                }
            }
            // else the sequence is empty, we are done!
            else
            {
                outcomes.score = score;
                outcomes.correct = (score / total).round(3);
                outcomes.rtTotal = results.filter(function( obj )
                                                 {return obj.type !== 'practice' &&
                                                         obj.state !== 'timeout';})
                                          .pluck("rt").sum().round(1);
                outcomes.medianFrametime = results.filter(function( obj )
                                                 {return obj.type !== 'practice' &&
                                                         obj.state !== 'timeout';})
                                          .pluck("frametime").median().round(2);
                outcomes.medianDuration = results.filter(function( obj )
                                                 {return obj.type !== 'practice' &&
                                                         obj.state !== 'timeout';})
                                          .pluck("duration").median().round(2);

                if(debug === "true") logResults([outcomes], 'cum');

                // we either save locally or to the server
                if(showresults === "true" || autosave === 'true' || filename)
                {
                    // if we save locally, append outcomes to results
                    outcomes.type = 'summaryScores';
                    results.push(outcomes);

                    showAlert("Your score is " + score + ".<br>" +
                              "<br>The test is over.<br>" +
                              "Thank you for participating!<br><br>",
                              "",
                              null,
                              '20pt');

                    setTimeout(function()
                    {
                        if(filename === false) filename = "MOTresults.csv";
                        tmbSubmitToFile(results,filename,autosave);
                    },2000);
                }
                else
                {
                    tmbSubmitToServer(results,score,outcomes);
                }
            }
        }

        function setFrameSequence()
        {
            var testMessage =
            {
                "begin":("<h2>Splitting Your Attention</h2>" +
                         "<img src=MOT.gif><br><br>"),
                "instruction1":("<h2>Instructions:</h2>" +
                                "<br><img src=happy-green-border.jpg><br>" +
                                "<br>Keep track of the dots that flash,<br>"+
                                "they have green smiles behind them.<br><br><br>"),
                "practice2":("<h2>Instructions:</h2>" +
                             "Next time, when the movement stops,<br>"+
                             "click the 2 dots that flashed.<br><br>"+
                             "The other dots have<br>"+
                             "red sad faces behind them.<br>"+
                             "<img src=sad-red-border.jpg><br>"+
                             "Try <b><i>not</i></b> to click on those.<br><br>"),
                "practice3":("<br><br><br>Good!<br><br>"+
                             "Now we'll do the same thing with<br>"+
                             "3 flashing dots.<br><br>"),
                "targets3":("<br><br>Great!<br><br>"+
                            "Now we'll do 6 more with 3 dots.<br>"+
                            "Motion is slow at first, then gets faster.<br>"+
                            "This will be the first of 3 parts.<br><br>"+
                            "When you lose track of dots, just guess.<br>"+
                            "Your score will be the total number of<br>"+
                            "green smiles that you click.<br><br>"),
                "targets3_noPrac":(
                            "The first part of the test has 3 flashing dots.<br>"+
                            "Motion is slow at first, then gets faster.<br>"+
                            "This will be the first of 3 parts.<br><br>"+
                            "When you lose track of dots, just guess.<br>"+
                            "Your score will be the total number of<br>"+
                            "green smiles that you click.<br><br>"),
                "targets4":("<br>Excellent!<br><br>"+
                            "You have finished the first part of this test.<br>"+  "" +
                            "There are two parts left.<br><br>" +
                            "The next part has 4 flashing dots.<br>"+
                            "Motion is slow at first, then gets faster.<br><br>"+
                            "When you lose track of dots, just guess.<br>"+
                            "Every smile you click adds to your score!<br><br>"),
                "targets5":("<br>Outstanding!<br><br>"+
                            "Now there is only one part left!<br><br>" +
                            "The final part has 5 flashing dots!<br>"+
                            "Motion is slow at first, then gets faster.<br><br>"+
                            "When you lose track of dots, just guess.<br>"+
                            "Every smile you click adds to your score!<br><br>"),
                "emaTargets5":("You will do this task <br>" +
                            "with 5 flashing dots!<br>"+
                            "Motion is slow at first, then gets faster.<br><br>"+
                            "When you lose track of dots, just guess.<br>"+
                            "Every smile you click adds to your score!<br><br>"),
                "noprac":("Remember:<br><br>" +
                          "Click on the dots with the green <br>" +
                          "smiley faces behind them.<br><br>")
            };

            // set the random generator's seed
            var s = seed;

			// view landing page unless there is optional practice skipping
            // (lab EMA version)
            if (noPractice !== 'optional')
            {
            	frame_type = ["begin"];
                frame_message = [testMessage.begin];
                frame_ntargets = [0];
                frame_speed = [0];

                // instructions and practice phase
                for (var i = 0; i < frame_type.length; i++)
                {
                    frameSequence.push(
                        {
                            type: frame_type[i],
                            n_targets: frame_ntargets[i],
                            n_circles: numCircles,
                            speed: frame_speed[i],
                            duration: 3000,
                            message: frame_message[i]
                        });
                }
            }

			// instructions frames
            var frame_type = ["message",
                              "example","message",
                              "practice","message","practice"];
            var frame_message = [testMessage.instruction1,
                                 "example1",testMessage.practice2,
                                 "practice1",testMessage.practice3,"practice2"];
            var frame_ntargets = [0,2,0,2,0,3];
            var frame_speed = [0,0.5,0,0.5,0,0.5];
            
            
            // add remaining frames depending on practice selection
            if (noPractice === 'false' || practiceChoice === 'noSkip')
				{

				// instructions and practice phase
				for(var i = 0; i < frame_type.length; i++)
				{
					frameSequence.push(
					{
						type: frame_type[i],
						n_targets: frame_ntargets[i],
						n_circles: numCircles,
						speed: frame_speed[i],
						duration: 3000,
						message: frame_message[i]
					});
				}
            } 
            else if (practiceChoice === 'skip')
            {
            	frame_type = ["message"];
                frame_message = [testMessage.noprac];
                frame_ntargets = [0];
                frame_speed = [0];

                // instructions and practice phase
                for (var i = 0; i < frame_type.length; i++) {
                    frameSequence.push(
                        {
                            type: frame_type[i],
                            n_targets: frame_ntargets[i],
                            n_circles: numCircles,
                            speed: frame_speed[i],
                            duration: 3000,
                            message: frame_message[i]
                        });
                }
            }
            else if (noPractice === 'true')
            {
            	frame_type = ["message"];
                frame_message = [testMessage.noprac];
                frame_ntargets = [0];
                frame_speed = [0];

                // instructions and practice phase
                for (var i = 0; i < frame_type.length; i++) {
                    frameSequence.push(
                        {
                            type: frame_type[i],
                            n_targets: frame_ntargets[i],
                            n_circles: numCircles,
                            speed: frame_speed[i],
                            duration: 3000,
                            message: frame_message[i]
                        });
                }
            }
            
            // if ema version, only 5-dot trials
            if (ema)
            {
            	var slowSpeed = 2; // base speed for ema trials
            	var change = 1;    // speed increase step for ema trials
            	
            	// test 5 dots
				frame_type = ["message","test","test","test","test","test","test"];
				frame_message = [testMessage.emaTargets5,"test"+(s+1),"test"+(s+3),
					"test"+(s+5),"test"+(s+7),"test"+(s+9),"test"+(s+11)];
				frame_speed = [0,0,0,0,0,0,0];
				for (var i=1; i<frame_speed.length; i++)
				{
					frame_speed[i] = slowSpeed + (i-1)*change;
				}

				for(i=0; i<frame_type.length; i++)
				{
					frameSequence.push(
							{
								type: frame_type[i],
								n_targets: 5,
								n_circles: numCircles,
								speed: frame_speed[i],
								duration: duration,
								message: frame_message[i]
							});
					if(demo==="true" && i===1) break;
				}
            }
            // if full length version, set up set size 3-5 trials
            else
            {

				// test 3 dots
				frame_type = ["message","test","test","test","test","test","test"];
				if (noPractice === 'true' || practiceChoice === 'skip')
				{
					var targets3message = testMessage.targets3_noPrac;
				}
				else
				{
					var targets3message = testMessage.targets3;
				}
				frame_message = [targets3message,"test"+(s),"test"+(s+1),"test"+(s+2),
								 "test"+(s+3),"test"+(s+4),"test"+(s+5),"test"+(s+6)];
				frame_speed = [0,1,2,3,4,5,6];

				for(i=0; i<frame_type.length; i++)
				{
					frameSequence.push(
					{
						type: frame_type[i],
						n_targets: 3,
						n_circles: numCircles,
						speed: frame_speed[i],
						duration: duration,
						message: frame_message[i]
					});
					if(demo==="true" && i===1) break;
				}

				// test 4 dots
				frame_message = [testMessage.targets4,"test"+(s+10),"test"+(s+11),"test"+(s+12),
								 "test"+(s+13),"test"+(s+14),"test"+(s+15),"test"+(s+16)];

				for(i=0; i<frame_type.length; i++)
				{
					frameSequence.push(
					{
						type: frame_type[i],
						n_targets: 4,
						n_circles: numCircles,
						speed: frame_speed[i],
						duration: duration,
						message: frame_message[i]
					});
					if(demo==="true" && i===1) break;
				}

				// test 5 dots
				frame_message = [testMessage.targets5,"test"+(s+20),"test"+(s+21),"test"+(s+22),
								 "test"+(s+23),"test"+(s+24),"test"+(s+25),"test"+(s+26)];

				for(i=0; i<frame_type.length; i++)
				{
					frameSequence.push(
					{
						type: frame_type[i],
						n_targets: 5,
						n_circles: numCircles,
						speed: frame_speed[i],
						duration: duration,
						message: frame_message[i]
					});
					if(demo==="true" && i===1) break;
				}
			}
			
            nextTrial();
        }

        window.onload = function()
        {
            var copyright = "Copyright " +
                            document.querySelector('meta[name="copyright"]').content;
            var scriptName = window.location.pathname.split('/').pop();

            // set the scale for mobile devices
            setBodyScale(560,600);

            // see if they are just asking for help
            if ((usage = getUrlParameters("help", "", true)))
            {
                showAlert("<p id='helpSpan'>" +
                    "<b>"+ document.title + "</b><br>" +
                    "<i>" + copyright + "</i><br><br>" +
                    "<b>Usage:</b>" +
                    "<br>" + scriptName + "?urlParam1=1&urlParam2=0<br><br>" +
                    "<b>URL Parameters</b>:<br>" +
                    "<i>dots=10</i> -- total dots to display (6-20)<br>" +
                    "<i>nopractice=false</i> -- whether practice trials should be skipped<br>" +
                    "<i>ema=false</i> -- whether the ema version of the test should be used<br>" +
                    "<i>seed=123</i> -- random number generator seed<br>" +
                    "<i>demo=true</i> -- runs in demo mode only for 10 seconds<br>" +
                    "<i>debug=true</i> -- outputs trial by trial info to the console<br>" +
                    "<i>showresults=true</i> -- allows to save results locally in a file<br>" +
                    "<i>autosave=true</i> -- will attempt to save results automatically to file<br>" +
                    "<i>filename=subject1.csv</i> -- the filename to save results to<br>" +
                    "<i>help -- print this message");
                document.getElementById('helpSpan').style.textAlign = 'left';
                document.getElementById('helpSpan').style.margin = '50px';
                return;
            }

            // check if this is a debug session
            debug = getUrlParameters("debug", "", true);

            // check if they want to load results in a new page when the test is over,
            // if data is to be saved automatically to a file and the filename
            showresults = getUrlParameters("showresults", "", true);
            autosave = getUrlParameters("autosave", "", true);
            filename = getUrlParameters("filename", "", true);

            // check if they want a quick run-through (only 1 trial per block)
            demo = getUrlParameters("demo","",true);

            // check if they want to change # of dots
            dots = getUrlParameters("dots","",true);
            if((dots = parseInt(dots)) > 5 && dots <= 20) numCircles = dots;

            // check if they want to set a random seed
            seed = getUrlParameters("seed","",true);
            if(!(seed = parseInt(seed))) seed = 1;
            
            // check if they want to showpractice
			noPractice = getUrlParameters("nopractice","",true);
			
			if (!noPractice)
			{
				noPractice = 'false';
			} 
			else if (noPractice !== 'false' && noPractice !== 'true' && noPractice !== 'optional')
			{
				showAlert("Error: Invalid value for url parameter 'nopractice'<br><br>" +
						  "Must be 'true', 'false', or 'optional'<br><br>",
						  "",
						  null,
						  '20pt');
				return;
			}
			
			// check if they want to use the ema version of the test
			ema = getUrlParameters("ema","",true);
			if(ema === 'true')
			{
				ema = true;
			} 
			else if (!ema || ema === 'false')
			{
				ema = false;
			} 
			else 
			{
				showAlert("Error: Invalid value for url parameter 'ema'<br><br>" +
						  "Must be 'true' or 'false'<br><br>",
						  "",
						  null,
						  '20pt');
				return;
			}

            // setup a canvas for Snap objects
            paper = Snap(paperSize, paperSize);
            getID("canvasContainer").appendChild(paper.node);

            // disable spurious user interaction
            disableSelect();
            disableRightClick();
            disableDrag();
        	disableDoubleTapZoom();

            getFrameTime(10,function(interval)
            {
                frametime = interval;

                var images = ['MOT.gif','happy-green-border.jpg','sad-red-border.jpg'];

				imagePreLoad(images, {callBack: function ()
                    {
					    // create the trials chain and start the testing sequence
					    if (noPractice === 'optional')
					    {
						    beginNoPractice();
					    }
					    else
					    {
                    	    setFrameSequence();
					    }
				    }
                });
            });
        }

    </script>

<!-- end of js script ****************************************************** -->

</head>

<!-- HTML content ********************************************************** -->

<body>

    <!-- this DIV contains the stimulus canvas -->
    <div class="stim" id="canvasContainer"></div>

    <!-- this DIV is used to give feedback -->
    <div class="feedback" id="feedback">
        <span id="textLeft"></span>
        <span id="textMiddle"></span>
        <span id="textRight"></span>
    </div>

    <noscript>
        For full functionality of this site it is necessary to enable JavaScript.<br>
        Here are the <a href="https://www.enable-javascript.com/" target="_blank" rel="noopener noreferrer">
        instructions</a> how to enable JavaScript in your web browser.
    </noscript>

</body>

</html>